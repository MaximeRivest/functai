
```{python}
from functai import ai

@ai(lm = "gpt-4.1")
def translator( 
    english # The English input text
) -> "french": ... # Use Quebec French

translator("Where is the convenience store?")
# > 'Où est le dépanneur?' 
```

And that is the prompt:

    [2025-08-31T21:15:21.446955]

    System message:

    Your input fields are:
    1. `english` (str):
    Your output fields are:
    1. `french` (str):
    All interactions will be structured in the following way, with the appropriate values filled in.

    [[ ## english ## ]]
    {english}

    [[ ## french ## ]]
    {french}

    [[ ## completed ## ]]
    In adhering to this structure, your objective is: 
            Function: translator
            
            Parameter guidance:
            - english: The English input text
            
            Return guidance: Use Quebec French


    User message:

    [[ ## english ## ]]
    Where is the convenience store?

    Respond with the corresponding output fields, starting with the field `[[ ## french ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.


    Response:

    [[ ## french ## ]]
    Où est le dépanneur?

    [[ ## completed ## ]]


It should be possible to annotate like that with comments and the instructions fields should be append with these comments (the they element they pertain to).

```{python}
from functai import ai, configure

configure(lm = "gpt-4.1")

class Account:
    id: int    # User ID
    email: str # Email address but without the extenstion

@ai
def extract_account(
    text: str  # Text block with account details
) -> Account:
    """Extract user ID and email."""
    ...

# Usage
extract_account("ID: 123, email: alice@example.com ")

# > Account(id=123, email='alice@example.com') 
```


Comments after _ai should also be 'harvested' and added to the instructions.

```{python}
from functai import ai, _ai

@ai()
def is_question(
    text: str  # Any input sentence
) -> bool:    # True if it's a question, False otherwise
    """Check if the input sentence is a question."""
    clues: str = _ai #Mention words or symbols that indicate a question (e.g., '?', 'who')."
    return _ai

# Usage
is_question("Who are you?")
# Returns: True (and .clues available if you inspect the full result)
```


Using flexiclass that shouls also be doable:

```{python}
from typing import List
from functai import ai, _ai

class Movie:
    title: str  # Movie title
    year: int   # Release year
    genres: List[str]  # List of genres

@ai()
def extract_movie(description: str  # Description to parse
                ) -> Movie:        # Extracted movie info
    """Extract movie details from a short text."""
    return _ai

# Usage
extract_movie("Inception, a 2010 sci-fi film starring Leonardo DiCaprio.")
```




```{python}
from functai import ai, _ai
from typing import Literal
import dspy

class PatientAddress:
    street: str
    city: str
    country: Literal["US", "CA"]

class PatientDetails:
    name: str # Full name of the patient
    age: int
    address: PatientAddress | None

@ai(lm = "gpt-4.1-mini")
def extract_patient_info(
    clinical_note
) -> PatientDetails:
    '''Extract patient information from the clinical note.'''

note = "John Doe, 45 years old, lives at 123 Main St, Anytown. Resident of the US."
extract_patient_info(note)

```



```{python}
from functai import ai, _ai
from typing import Literal
from pydantic import BaseModel, Field


# 1. Define Pydantic models
class ClinicalNote(BaseModel):
    text: str

class PatientAddress(BaseModel):
    street: str
    city: str
    country: Literal["US", "CA"]

class PatientDetails(BaseModel):
    name: str = Field(description="Full name of the patient.")
    age: int
    address: PatientAddress | None

# 2. Define the function
@ai(lm = "gpt-4.1-mini")
def extract_patient_info(
    clinical_note: ClinicalNote
) -> PatientDetails:
    '''Extract patient information from the clinical note.'''

note = "John Doe, 45 years old, lives at 123 Main St, Anytown. Resident of the US."

extract_patient_info(ClinicalNote(text = note))
```








[2025-08-31T22:05:20.481897]

System message:

Your input fields are:
1. `clinical_note` (ClinicalNote):
Your output fields are:
1. `PatientDetails` (PatientDetails):
All interactions will be structured in the following way, with the appropriate values filled in.

[[ ## clinical_note ## ]]
{clinical_note}

[[ ## PatientDetails ## ]]
{PatientDetails}        # note: the value you produce must adhere to the JSON schema: {"type": "object", "$defs": {"PatientAddress": {"type": "object", "properties": {"city": {"type": "string", "title": "City"}, "country": {"type": "string", "enum": ["US", "CA"], "title": "Country"}, "street": {"type": "string", "title": "Street"}}, "required": ["street", "city", "country"], "title": "PatientAddress"}}, "properties": {"address": {"anyOf": [{"$ref": "#/$defs/PatientAddress"}, {"type": "null"}]}, "age": {"type": "integer", "title": "Age"}, "name": {"type": "string", "description": "Full name of the patient.", "title": "Name"}}, "required": ["name", "age", "address"], "title": "PatientDetails"}

[[ ## completed ## ]]
In adhering to this structure, your objective is: 
        Function: extract_patient_info
        
        Extract patient information from the clinical note.
        
        - PatientDetails.name: Full name of the patient
        - PatientDetails.age
        - PatientDetails.address


User message:

[[ ## clinical_note ## ]]
{"text": "John Doe, 45 years old, lives at 123 Main St, Anytown. Resident of the US."}

Respond with the corresponding output fields, starting with the field `[[ ## PatientDetails ## ]]` (must be formatted as a valid Python PatientDetails), and then ending with the marker for `[[ ## completed ## ]]`.


Response:

[[ ## PatientDetails ## ]]
{"name": "John Doe", "age": 45, "address": {"street": "123 Main St", "city": "Anytown", "country": "US"}}
[[ ## completed ## ]]





